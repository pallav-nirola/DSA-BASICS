using namespace std;
#include <iostream>
#include <vector>
#include <queue>
static int idx = -1;
class Node
{

public:
    int data;
    Node *left;
    Node *right;
    Node(int val)
    {

        data = val;
        left = NULL;
        right = NULL;
    }
};
Node *builtTree(vector<int> v)
{
    idx++;
    if (v[idx] == -1)
    {
        return NULL;
    }
    else
    {
        Node *root = new Node(v[idx]);
        (*root).left = builtTree(v);
        (*root).right = builtTree(v);
        return root;
    }
}
void preOrder_Traversal(Node *root) // root left right
{

    if (root == NULL)
    {
        return;
    }
    else
    {
        cout << (*root).data << " ";
        preOrder_Traversal((*root).left);
        preOrder_Traversal((*root).right);
    }
}
void inOrder_traversal(Node *root) // left root right
{
    if (root == NULL)
    {
        return;
    }
    else
    {
        inOrder_traversal((*root).left);
        cout << (*root).data << " ";
        inOrder_traversal((*root).right);
    }
}
void postOrder_traversal(Node *root)
{ // left right root

    if (root == NULL)
    {
        return;
    }
    else
    {
        postOrder_traversal((*root).left);

        postOrder_traversal((*root).right);
        cout << (*root).data << " ";
    }
}
void levelOrder_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        cout << (*temp).data << " ";
        q.pop();

        if ((*temp).left!=NULL)
        {
            q.push((*temp).left);
        }
        if ((*temp).right!=NULL)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}
void levelOrderLineWise_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        q.pop();

        if (temp == NULL)
        {
            if (q.empty() == 0)
            {
                cout << endl;
                q.push(NULL);
                continue;
            }
            else
            {
                break;
            }
        }

        cout << temp->data << " ";

        if ((*temp).left)
        {
            q.push((*temp).left);
        }
        if ((*temp).right)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}

int heightMax(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftHeight = heightMax((*root).left);
        int rightHeight = heightMax((*root).right);
        return max(leftHeight, rightHeight) + 1;
    }
}
int countNode(Node *root){

    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftCount = countNode((*root).left);
        int rightCount = countNode((*root).right);
        return (leftCount + rightCount + 1);
    }
    
}
int sumNode(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftsum = sumNode((*root).left);
        int rightsum = sumNode((*root).right);
        return (leftsum + rightsum + (*root).data);
    }
}
bool isIdentical(Node *p, Node *q)
{

    if (p == NULL && q == NULL)
    {
        return true;
    }
    if (p == NULL || q == NULL)
    {
        return false;
    }
    if ((*p).data != (*q).data)
    {
        return false;
    }
    bool leftSum = isIdentical((*p).left, (*q).left);
    if (leftSum == false)
    {
        return false;
    }
bool rightSum = isidentical((*p).right, (*q).right);
    if (rightSum == false)
    {
        return false;
    }
    return true;
    
}
bool isSubtree(Node* root, Node* subRoot) {
    if (root == NULL) return false;

    if ((*root).data == (*subRoot).data) {
        if (isIdentical(root, subRoot)) return true;
    }
else{
        // continue searching in left and right subtree
    }

    bool leftCheck = isSubtree((*root).left, subRoot);
    if (leftCheck == true) return true;

    bool rightCheck = isSubtree((*root).right, subRoot);
    if (rightCheck == true) return true;

    return false;
}
int main()
{
    vector<int> preOrder = {1, 2, -1, -1, 3, 4, -1, -1, 5, -1, -1};
    Node *root = builtTree(preOrder);

    return 0;
}
