using namespace std;
#include <iostream>
#include <vector>
#include <queue>
static int idx = -1;
class Node
{

public:
    int data;
    Node *left;
    Node *right;
    Node(int val)
    {

        data = val;
        left = NULL;
        right = NULL;
    }
};
Node *builtTree(vector<int> v)
{
    idx++;
    if (v[idx] == -1)
    {
        return NULL;
    }
    else
    {
        Node *root = new Node(v[idx]);
        (*root).left = builtTree(v);
        (*root).right = builtTree(v);
        return root;
    }
}
void preOrder_Traversal(Node *root) // root left right
{

    if (root == NULL)
    {
        return;
    }
    else
    {
        cout << (*root).data << " ";
        preOrder_Traversal((*root).left);
        preOrder_Traversal((*root).right);
    }
}
void inOrder_traversal(Node *root) // left root right
{
    if (root == NULL)
    {
        return;
    }
    else
    {
        inOrder_traversal((*root).left);
        cout << (*root).data << " ";
        inOrder_traversal((*root).right);
    }
}
void postOrder_traversal(Node *root)
{ // left right root

    if (root == NULL)
    {
        return;
    }
    else
    {
        postOrder_traversal((*root).left);

        postOrder_traversal((*root).right);
        cout << (*root).data << " ";
    }
}
void levelOrder_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        cout << (*temp).data << " ";
        q.pop();

        if ((*temp).left!=NULL)
        {
            q.push((*temp).left);
        }
        if ((*temp).right!=NULL)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}
void TopViewOfATree(Node *root)
{
    if (root == NULL)
        return;
    queue<pair<Node *, int>> q;
    map<int, Node *> m;
    q.push({root, 0});
    while (q.empty() == 0)
    {

        map<int, Node *> ::iterator it;

        Node *temp = q.front().first; // for pair 1 of q
        int *hd = q.front().second;// for pair 2 of q
        it = m.find(hd);
        q.pop();
        if (it == m.end())
        {
            m[hd] = temp;
        }
        if ((*temp).left != NULL)
        {
            q.push({(*temp).left, hd - 1});
        }
        if ((*temp).right != NULL)
        {
            q.push({(*temp).right, hd + 1});
        }
    }
    map<int, Node *>::iterator itr;
    for (itr = m.begin(); itr != m.end(); itr++)
    {
        cout << (*(*itr).second).data << " ";
    }
}
void kthLevelRecursion(Node *root, int K)
{

    if (K == NULL)
    {
        return;
    }
    if (K == 1)
    {
        cout << (*root).data<< endl;
        return ;
    }
    kthLevel((*root).left , K-1);
    kthLevel((*root).right , K-1);
}
void kthLevelIterative(Node *root, int K)
{
    if (root == NULL)
        return;

    queue<Node*> q;
    q.push(root);

    int level = 1;

    while (!q.empty())
    {
        int size = q.size();

        if (level == K)
        {
            for (int i = 0; i < size; i++)
            {
                Node* curr = q.front();
                q.pop();
                cout << curr->data << " ";
            }
            cout << endl;
            return;
        }

        for (int i = 0; i < size; i++)
        {
            Node* curr = q.front();
            q.pop();

            if (curr->left != NULL)
                q.push(curr->left);

            if (curr->right != NULL)
                q.push(curr->right);
        }

        level++;
    }
}
int SumNodeTree(Node *root)
{
    if (root == NULL)
    {
        return 0;
    }
    int LeftSum = SumNodeTree((*root).left);
    int RightSum = SumNodeTree((*root).right);
    ((*root).data) = ((*root).data) + leftSum + RightSum;
    return (*root).data;
}


void levelOrderLineWise_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        q.pop();

        if (temp == NULL)
        {
            if (q.empty() == 0)
            {
                cout << endl;
                q.push(NULL);
                continue;
            }
            else
            {
                break;
            }
        }

        cout << temp->data << " ";

        if ((*temp).left)
        {
            q.push((*temp).left);
        }
        if ((*temp).right)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}
Node* LowestCommonAncestoral(Node* root, int p, int q) {
    if (root == NULL) return NULL;

    if (root->data == p || root->data == q)
        return root;

    Node* leftLCA = LowestCommonAncestoral(root->left, p, q);
    Node* rightLCA = LowestCommonAncestoral(root->right, p, q);

    if (leftLowestCommonAncestoral != NULL && rightLowestCommonAncestoral != NULL)
        return root;

    if (leftLowestCommonAncestoral != NULL)
        return leftLowestCommonAncestoral;
    else
        return rightLowestCommonAncestoral;
}


int heightMax(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftHeight = heightMax((*root).left);
        int rightHeight = heightMax((*root).right);
        return max(leftHeight, rightHeight) + 1;
    }
}
int countNode(Node *root){

    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftCount = countNode((*root).left);
        int rightCount = countNode((*root).right);
        return (leftCount + rightCount + 1);
    }
    
}
int sumNode(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftsum = sumNode((*root).left);
        int rightsum = sumNode((*root).right);
        return (leftsum + rightsum + (*root).data);
    }
}
bool isIdentical(Node *p, Node *q)
{

    if (p == NULL && q == NULL)
    {
        return true;
    }
    if (p == NULL || q == NULL)
    {
        return false;
    }
    if ((*p).data != (*q).data)
    {
        return false;
    }
    bool leftSum = isIdentical((*p).left, (*q).left);
    if (leftSum == false)
    {
        return false;
    }
bool rightSum = isidentical((*p).right, (*q).right);
    if (rightSum == false)
    {
        return false;
    }
    return true;
    
}
bool isSubtree(Node* root, Node* subRoot) {
    if (root == NULL) return false;

    if ((*root).data == (*subRoot).data) {
        if (isIdentical(root, subRoot)) return true;
    }
else{
        // continue searching in left and right subtree
    }

    bool leftCheck = isSubtree((*root).left, subRoot);
    if (leftCheck == true) return true;

    bool rightCheck = isSubtree((*root).right, subRoot);
    if (rightCheck == true) return true;

    return false;
}
int main()
{
    vector<int> preOrder = {1, 2, -1, -1, 3, 4, -1, -1, 5, -1, -1};
    Node *root = builtTree(preOrder);

    return 0;
}
