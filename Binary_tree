using namespace std;
#include <iostream>
#include <vector>
#include <queue>
static int idx = -1;
class Node
{

public:
    int data;
    Node *left;
    Node *right;
    Node(int val)
    {

        data = val;
        left = NULL;
        right = NULL;
    }
};
Node *builtTree(vector<int> v)
{
    idx++;
    if (v[idx] == -1)
    {
        return NULL;
    }
    else
    {
        Node *root = new Node(v[idx]);
        (*root).left = builtTree(v);
        (*root).right = builtTree(v);
        return root;
    }
}
void preOrder_Traversal(Node *root) // root left right
{

    if (root == NULL)
    {
        return;
    }
    else
    {
        cout << (*root).data << " ";
        preOrder_Traversal((*root).left);
        preOrder_Traversal((*root).right);
    }
}
void inOrder_traversal(Node *root) // left root right
{
    if (root == NULL)
    {
        return;
    }
    else
    {
        inOrder_traversal((*root).left);
        cout << (*root).data << " ";
        inOrder_traversal((*root).right);
    }
}
void morrisInorder(Node* root) {
    Node* curr = root;
    while (curr != nullptr) {
        if (curr->left == nullptr) {
            // Print the current node
            cout << curr->data << " ";
            curr = curr->right;
        } else {
            // Find the inorder predecessor of curr
            Node* pre = curr->left;
            while (pre->right != nullptr && pre->right != curr)
                pre = pre->right;

            // Make current as the right child of its inorder predecessor
            if (pre->right == nullptr) {
                pre->right = curr; // Create a thread
                curr = curr->left;
            } 
            // Revert the changes made (remove the thread)
            else {
                pre->right = nullptr;
                cout << curr->data << " ";
                curr = curr->right;
            }
        }
    }
}
void postOrder_traversal(Node *root)
{ // left right root

    if (root == NULL)
    {
        return;
    }
    else
    {
        postOrder_traversal((*root).left);

        postOrder_traversal((*root).right);
        cout << (*root).data << " ";
    }
}
void levelOrder_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        cout << (*temp).data << " ";
        q.pop();

        if ((*temp).left!=NULL)
        {
            q.push((*temp).left);
        }
        if ((*temp).right!=NULL)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}
void TopViewOfATree(Node *root)
{
    if (root == NULL)
        return;
    queue<pair<Node *, int>> q;
    map<int, Node *> m;
    q.push({root, 0});
    while (q.empty() == 0)
    {

        map<int, Node *> ::iterator it;

        Node *temp = q.front().first; // for pair 1 of q
        int *hd = q.front().second;// for pair 2 of q
        it = m.find(hd);
        q.pop();
        if (it == m.end())
        {
            m[hd] = temp;
        }
        if ((*temp).left != NULL)
        {
            q.push({(*temp).left, hd - 1});
        }
        if ((*temp).right != NULL)
        {
            q.push({(*temp).right, hd + 1});
        }
    }
    map<int, Node *>::iterator itr;
    for (itr = m.begin(); itr != m.end(); itr++)
    {
        cout << (*(*itr).second).data << " ";
    }
}
void kthLevelRecursion(Node *root, int K)
{

    if (K == NULL)
    {
        return;
    }
    if (K == 1)
    {
        cout << (*root).data<< endl;
        return ;
    }
    kthLevel((*root).left , K-1);
    kthLevel((*root).right , K-1);
}
void kthLevelIterative(Node *root, int K)
{
    if (root == NULL)
        return;

    queue<Node*> q;
    q.push(root);

    int level = 1;

    while (!q.empty())
    {
        int size = q.size();

        if (level == K)
        {
            for (int i = 0; i < size; i++)
            {
                Node* curr = q.front();
                q.pop();
                cout << curr->data << " ";
            }
            cout << endl;
            return;
        }

        for (int i = 0; i < size; i++)
        {
            Node* curr = q.front();
            q.pop();

            if (curr->left != NULL)
                q.push(curr->left);

            if (curr->right != NULL)
                q.push(curr->right);
        }

        level++;
    }
}
int SumNodeTree(Node *root)
{
    if (root == NULL)
    {
        return 0;
    }
    int LeftSum = SumNodeTree((*root).left);
    int RightSum = SumNodeTree((*root).right);
    ((*root).data) = ((*root).data) + leftSum + RightSum;
    return (*root).data;
}


void levelOrderLineWise_traversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (q.empty() == 0)
    {
        Node *temp = q.front();
        q.pop();

        if (temp == NULL)
        {
            if (q.empty() == 0)
            {
                cout << endl;
                q.push(NULL);
                continue;
            }
            else
            {
                break;
            }
        }

        cout << temp->data << " ";

        if ((*temp).left)
        {
            q.push((*temp).left);
        }
        if ((*temp).right)
        {
            q.push((*temp).right);
        }
    }
    cout << endl;
}
Node* LowestCommonAncestoral(Node* root, int p, int q) {
    if (root == NULL) return NULL;

    if (root->data == p || root->data == q)
        return root;

    Node* leftLCA = LowestCommonAncestoral(root->left, p, q);
    Node* rightLCA = LowestCommonAncestoral(root->right, p, q);

    if (leftLowestCommonAncestoral != NULL && rightLowestCommonAncestoral != NULL)
        return root;

    if (leftLowestCommonAncestoral != NULL)
        return leftLowestCommonAncestoral;
    else
        return rightLowestCommonAncestoral;
}


int heightMax(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftHeight = heightMax((*root).left);
        int rightHeight = heightMax((*root).right);
        return max(leftHeight, rightHeight) + 1;
    }
}
bool isBalancedTrreBOOL(Node *root)//O(n^2) approach;
{
    if (root == NULL)
        return true;
    int heightleft = heightMax(root->left);
    int heightright = heightMax(root->right);
    if (abs(heightleft - heightright) <= 1 && isBalancedTrreBOOL(root->left) && isBalancedTrreBOOL(root->right))
        return true;
    return false;
}
int checkBalance(Node* root)//O(n) approach
{
    if (root == NULL)
        return 0;
    int leftHeight = checkBalance(root->left);
    if (leftHeight == -1) return -1;

    int rightHeight = checkBalance(root->right);
    if (rightHeight == -1) return -1;

    if (abs(leftHeight - rightHeight) > 1)
        return -1;
        else{
    return max(leftHeight, rightHeight) + 1;
        }
}
bool isBalanced(Node* root)
{
    int result = checkBalance(root);
    if (result == -1)
        return false; 
    else
        return true;  
}
int countNode(Node *root){

    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftCount = countNode((*root).left);
        int rightCount = countNode((*root).right);
        return (leftCount + rightCount + 1);
    }
    
}
int sumNode(Node *root){
    if (root==NULL)
    {
        return 0;
    }
    else{
        int leftsum = sumNode((*root).left);
        int rightsum = sumNode((*root).right);
        return (leftsum + rightsum + (*root).data);
    }
}
bool isIdentical(Node *p, Node *q)
{

    if (p == NULL && q == NULL)
    {
        return true;
    }
    if (p == NULL || q == NULL)
    {
        return false;
    }
    if ((*p).data != (*q).data)
    {
        return false;
    }
    bool leftSum = isIdentical((*p).left, (*q).left);
    if (leftSum == false)
    {
        return false;
    }
bool rightSum = isidentical((*p).right, (*q).right);
    if (rightSum == false)
    {
        return false;
    }
    return true;
    
}
bool isSubtree(Node* root, Node* subRoot) {
    if (root == NULL) return false;

    if ((*root).data == (*subRoot).data) {
        if (isIdentical(root, subRoot)) return true;
    }
else{
        // continue searching in left and right subtree
    }

    bool leftCheck = isSubtree((*root).left, subRoot);
    if (leftCheck == true) return true;

    bool rightCheck = isSubtree((*root).right, subRoot);
    if (rightCheck == true) return true;

    return false;
}
int sumTree(Node *root)
{
    if (root == NULL)
    {
        return 0;
    }
    int leftSum = sumTree((*root).left);
    int rightSum = sumTree((*root).right);
    (*root).data = (*root).data + leftSum + rightSum;
    return (*root).data;
}
int main()
{
    vector<int> preOrder = {1, 2, 4, -1, -1, 5, -1, -1, 3, 6, -1,-1 , -1};
    Node *root = builtTree(preOrder);

    return 0;
}
