undirected graph using dfs
bool ISCircular(int source, int vertex, vector<int> adj[], vector<bool> &vis, int parent)
    {
        vis[source] = true;
        for (int neighbour : adj[source])
        {
            if (vis[neighbour] != true)
            {
               if( ISCircular(neighbour, vertex, adj, vis, source)==true) // when we find the cycle and the line 17 will rturn true , and for line 9 if true then it owuld auto return true to the func{
               return true;
               }
            }
            else if (vis[neighbour] == true && neighbour == parent)
            {
            }
            else if (vis[neighbour] == true && neighbour != parent)
            {
                return true;
            }
        }
        return false;
    }

undirected graph using bfs
bool iscircular(int vertex, int source, vector<int> adj[], int par)
    {
        queue<pair<int, int>> q;
        vector<bool> vist(vertex, false);
        q.push({source, -1});
        vist[source] = true;
        while (q.empty() == 0)
        {
            int node = q.front().first;
            int parent = q.front().second;
            q.pop();
            for (int neighbour : adj[node])
            {
                if (vist[neighbour] != true)
                {
                    q.push({neighbour, node});
                    vist[neighbour] = true;
                }
                else if (vist[neighbour] == true && neighbour == parent)
                {
                }
                else if (vist[neighbour] == true && neighbour != parent)
                {
                    return true;
                }
            }
        }
        return false;
    }
Directed graph using dfs 
#include <bits/stdc++.h>
using namespace std;

// Function to detect a cycle starting from 'node'
bool ISCircularDirected(int node, vector<int> adj[], vector<bool> &visited, vector<bool> &recStack)
{
    visited[node] = true;
    recStack[node] = true;  // mark node as part of current DFS path

    for (int neighbour : adj[node])
    {
        if (!visited[neighbour])
        {
            // Recursively visit neighbor
            if (ISCircularDirected(neighbour, adj, visited, recStack))
                return true;  // cycle found in deeper DFS
        }
        else if (recStack[neighbour])
        {
            // neighbor is in current recursion stack → back edge → cycle detected
            return true;
        }
    }

    // ===================== IMPORTANT =====================
    // Example graph:
    // 0 → 1 → 2
    // ↓
    // 3 → 4
    //
    // DFS starts at node 0.
    // recStack[0] = true
    //
    // DFS path 0 → 1 → 2:
    // - Node 2 has no outgoing edges → DFS returns false
    // - If we don't set recStack[2] = false, node 2 stays marked in the recursion stack
    // - Backtrack to 1 → then backtrack to 0
    //
    // DFS path 0 → 3 → 4:
    // - Node 4 has no outgoing edges
    // - If we reach 2 from somewhere else later, recStack[2] is still true
    // - DFS would incorrectly think 2 is on the current DFS path → false cycle detected
    //
    // Therefore, we **must remove the node from the recursion stack** after finishing its DFS:
    recStack[node] = false; // remove node from current DFS path

    return false; // no cycle detected from this path
}

// Wrapper function to check for cycle in the whole graph
bool hasCycleDirected(int V, vector<int> adj[])
{
    vector<bool> visited(V, false);
    vector<bool> recStack(V, false);

    for (int i = 0; i < V; i++)
    {
        if (!visited[i] && ISCircularDirected(i, adj, visited, recStack))
            return true;  // cycle exists
    }
    return false; // no cycle in the graph
}

// Example usage
int main()
{
    int V = 5; // number of vertices
    vector<int> adj[V];

    // Graph: 0→1→2, 0→3→4
    adj[0].push_back(1);
    adj[1].push_back(2);
    adj[0].push_back(3);
    adj[3].push_back(4);

    if (hasCycleDirected(V, adj))
        cout << "Cycle detected\n";
    else
        cout << "No cycle\n";

    return 0;
}
