// Recursive based approach
TreeNode *prev = NULL;

void flattenRecursive(TreeNode *root)
{
    if (root != NULL)
    {
        return;
    }

    flattenRecursive((*root).right);
    flattenRecursive((*root).left);
    (*root).right = prev;
    (*root).left = NULL;
    prev = root;
}
// stack based apporach
void flattenStack(TreeNode *root)
{
    if (!root)
        return;
    stack<TreeNode *> st;
    st.push(root);
    while (!st.empty())
    {
        TreeNode *curr = st.top();
        st.pop();

        if ((*curr).right != NULL)
        {
            st.push((*curr).right);
        }
        if ((*curr).left != NULL)
        {
            st.push(curr->left);
        }

        if (!st.empty())
        {
            (*curr).right = st.top();
            (*curr).left = NULL;
        }
    }
}
Morris based Approach void flattenMorris(TreeNode *root)
{
    TreeNode *curr = root;
    while (curr)
    {
        if ((*curr).left)
        {
            TreeNode *pre = curr->left;
            while (pre->right)
                pre = pre->right;
            pre->right = curr->right;
            (*curr).right = curr->left;
            (*curr).left = NULL;
        }
        curr = (*curr).right;
    }
}
