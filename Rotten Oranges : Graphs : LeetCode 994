#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int orangesRotting(vector<vector<int>> &grid)
{
    int row = grid.size();    // number of rows
    int column = grid[0].size(); // number of columns
    // visited array to mark processed cells
    vector<vector<int>> visited(row, vector<int>(column, 0));
    // queue will store {row, col, time}
    queue<pair<pair<int, int>, int>> q;
    int fresh = 0; // count of fresh oranges initially
    // Step 1: Put all rotten oranges in queue and mark visited
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < column; j++)
        {
            if (grid[i][j] == 2)
            {
                q.push({{i, j}, 0}); // rotten orange with time = 0
                visited[i][j] = 1;
            }
            else if (grid[i][j] == 1)
            {
                fresh++; // count fresh oranges
            }
        }
    }
    // Directions for up, down, left, right
    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};
    int totalTime = 0;
    int rottenCount = 0;
    // Step 2: BFS traversal
    while (!q.empty())
    {
        int row = q.front().first.first;
        int col = q.front().first.second;
        int time = q.front().second;
        q.pop();
        totalTime = max(totalTime, time); // track max time
        // check 4 directions
        for (int i = 0; i < 4; i++)
        {
            int newRow = row + dx[i];
            int newCol = col + dy[i];
            // check if inside grid and not visited
if (newRow >= 0 && newCol >= 0 && newRow < row && newCol < column
 && visited[newRow][newCol] == 0 && grid[newRow][newCol] == 1)
            {
                // mark as rotten
                grid[newRow][newCol] = 2;
                visited[newRow][newCol] = 1;
                rottenCount++;
                q.push({{newRow, newCol}, time + 1});
            }
        }
    }
    if (rottenCount == fresh)
        return totalTime;
    else
        return -1;
}
int main()
{
    vector<vector<int>> grid = {
        {2, 1, 1},
        {1, 1, 0},
        {0, 1, 1}};
    cout << "Minutes to rot all oranges: " << orangesRotting(grid);
    return 0;
}
