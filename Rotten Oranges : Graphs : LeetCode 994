#include <iostream>
#include <vector>
#include <queue>
using namespace std;
Shraddha Solution 
int rotten_Oranges(int veretx, int source, vector<vector<int>> &grid)
    {
        queue<pair<pair<int, int>, int>> qu; // node with with time
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));    int ans = 0;
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (grid[i][j] == 2 && vis[i][j] != true)
                {
                    qu.push({{i, j}, 0});
                    vis[i][j] = true;
                }
            }
        }
        while (qu.empty() == 0)
        {
            int x = qu.front().first.first;
            int y = qu.front().first.second;
            int time = qu.front().second;
         
            qu.pop();
            if (x >= 0 && y + 1 >= 0 && x < n && y + 1 < m && grid[x][y + 1] == 1)
            {
                qu.push({{x, y + 1}, time + 1});
                vis[x][y + 1] = true;
            }
            if (x + 1 >= 0 && y >= 0 && x + 1 < n && y < m && grid[x + 1][y] == 1)
            {
                qu.push({{x + 1, y}, time + 1});
                vis[x + 1][y] = true;
            }
            if (x >= 0 && y - 1 >= 0 && x < n && y - 1 < m && grid[x][y - 1] == 1)
            {
                qu.push({{x, y - 1}, time + 1});
                vis[x][y - 1] = true;
            }
            if (x - 1 >= 0 && y >= 0 && x - 1 < n && y < m && grid[x - 1][y] == 1)
            {
                qu.push({{x - 1, y}, time + 1});
                vis[x - 1][y] = true;
            }
             ans = time;
        }
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (grid[i][j] == 1 && vis[i][j] != true)
                {
                    return -1;
                }
            }
        }
        return ans;
    }
Striver Solution
int orangesRotting(vector<vector<int>> &grid)
{
    int row = grid.size();    // number of rows
    int column = grid[0].size(); // number of columns
    // visited array to mark processed cells
    vector<vector<int>> visited(row, vector<int>(column, 0));
    // queue will store {row, col, time}
    queue<pair<pair<int, int>, int>> q;
    int fresh = 0; // count of fresh oranges initially
    // Step 1: Put all rotten oranges in queue and mark visited
    for (int i = 0; i < row; i++)
    {
        for (int j = 0; j < column; j++)
        {
            if (grid[i][j] == 2)
            {
                q.push({{i, j}, 0}); // rotten orange with time = 0
                visited[i][j] = 1;
            }
            else if (grid[i][j] == 1)
            {
                fresh++; // count fresh oranges
            }
        }
    }
    // Directions for up, down, left, right
    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};
    int totalTime = 0;
    int rottenCount = 0;
    // Step 2: BFS traversal
    while (!q.empty())
    {
        int row = q.front().first.first;
        int col = q.front().first.second;
        int time = q.front().second;
        q.pop();
        totalTime = max(totalTime, time); // track max time
        // check 4 directions
        for (int i = 0; i < 4; i++)
        {
            int newRow = row + dx[i];
            int newCol = col + dy[i];
            // check if inside grid and not visited
if (newRow >= 0 && newCol >= 0 && newRow < row && newCol < column
 && visited[newRow][newCol] == 0 && grid[newRow][newCol] == 1)
            {
                // mark as rotten
                grid[newRow][newCol] = 2;
                visited[newRow][newCol] = 1;
                rottenCount++;
                q.push({{newRow, newCol}, time + 1});
            }
        }
    }
    if (rottenCount == fresh)
        return totalTime;
    else
        return -1;
}
int main()
{
    vector<vector<int>> grid = {
        {2, 1, 1},
        {1, 1, 0},
        {0, 1, 1}};
    cout << "Minutes to rot all oranges: " << orangesRotting(grid);
    return 0;
}
