// naive approach
#include <iostream>
using namespace std;
int main()
{
    int prices[] = {100, 80, 60, 70, 60, 75, 85};
    int n = sizeof(prices) / sizeof(prices[0]);
   vector<int>span;
    for (int i = 0; i < n; i++)
    {
int span_count = 1;
        int j = i - 1;
        while (j >= 0 && prices[i] >= prices[j])
        {
          span_count++;
            j--;
        }
        span.push_back(span_count);
    }
    for (int i = 0; i < n; i++)
    {
        cout << span[i] << " ";
    }
    return 0;
}
// stack approach 
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
int main() {
    vector<int> prices = {6, 8, 7, 1, 3};
    int n = prices.size();
    vector<int> span(n, 1); // span at least 1
    stack<pair<int,int>> stk; // {index, price}

    for (int i = 0; i < n; i++)
    {
        if (stk.empty() == 1)
        {
            stk.push({i, prices[i]});
        }
        else
        {
            if (prices[i] > stk.top().second)
            {
                // pop smaller/equal elements to get correct span
                while (stk.empty() == 0 && stk.top().second <= prices[i])
                {
                    stk.pop();
                }

                if (stk.empty() == 0)
                    span[i] = i - stk.top().first;
                else
                    span[i] = i + 1;

                stk.push({i, prices[i]});
            }
            else
            {
                // current price â‰¤ top price
                span[i] = 1; // only itself counts
                stk.push({i, prices[i]});
            }
        }
    }
    cout << "Stock Span: ";
    for (int s : span)
        cout << s << " ";
    cout << endl;
    return 0;
}
